Authored by: Shravani Thimanadoddi
Date: Aug 19, 2020

Usage:
RandomSequenceGenerator <count> <strategy:1|2|3>
Configure the input parameters in Debug -> Application Arguments as 10000 2

This program takes as input 2 parameters:
count: The upper limit on the random sequence to generate
strategy: Could be one of 1,2, or 3. This will determine the random sequence generation strategy to choose from

This solution is implemented using strategy design pattern where we are able to inject the strategy of choice into the random sequence generation

We have a RandomSequenceStrategy interface that has one function generateRandomSequence() that will return an enumerable int collection.
The interface is implemented by three classes - namely, RandomSequenceStrategy1, RandomSequenceStrategy2, RandomSequenceStrategy3

All three strategies have been tested to find relatively same time complexity

RandomSequenceStrategy1:
This class uses a simple scheme where we are trying to build an int array with random numbers. For this we are iterating over the entire
range of sequence that we want and adding them in random positions in the array. With each iteration, we are keeping track of the availble
positions in the array. This approach has the advantage of minimizing the number of iterations needed to build the sequence. However this will
require more memory as we are maintaining 2 collections - one for the random number sequence, the other for keeping track of available positions

RandomSequenceStrategy2:
This class takes advantage of a HashSet that will only allow unique values in its collection of numbers. This is a brute force method where
we are continuously generating random numbers and trying to insert them until we succeed and we fill all the numbers. Surprisingly this approach
is still giving a good better performance than strategy 1 above. However, this may cause many more iterations depending on how frequently
we get duplicate values generated by the Random class

RandomSequenceStrategy3:
This class takes advantage of the Random Shuffle that is possible using the in-built classes of C#.NET. We create a straight sequence of numbers
first and then sort them using a random key, leading to a random shuffle.
